// Code generated by counterfeiter. DO NOT EDIT.
package apifakes

import (
	"sync"

	"github.com/baotingfang/go-pivnet-client/api"
	"github.com/baotingfang/go-pivnet-client/config"
)

type FakeAccessInterface struct {
	AddProductFileToFileGroupStub        func(int64, int64) error
	addProductFileToFileGroupMutex       sync.RWMutex
	addProductFileToFileGroupArgsForCall []struct {
		arg1 int64
		arg2 int64
	}
	addProductFileToFileGroupReturns struct {
		result1 error
	}
	addProductFileToFileGroupReturnsOnCall map[int]struct {
		result1 error
	}
	AddProductFileToReleaseStub        func(int64, int64) error
	addProductFileToReleaseMutex       sync.RWMutex
	addProductFileToReleaseArgsForCall []struct {
		arg1 int64
		arg2 int64
	}
	addProductFileToReleaseReturns struct {
		result1 error
	}
	addProductFileToReleaseReturnsOnCall map[int]struct {
		result1 error
	}
	CreateFederationTokenStub        func() (*api.FederationTokenResponse, error)
	createFederationTokenMutex       sync.RWMutex
	createFederationTokenArgsForCall []struct {
	}
	createFederationTokenReturns struct {
		result1 *api.FederationTokenResponse
		result2 error
	}
	createFederationTokenReturnsOnCall map[int]struct {
		result1 *api.FederationTokenResponse
		result2 error
	}
	CreateFileGroupStub        func(config.FileGroup) (*api.GroupResponse, error)
	createFileGroupMutex       sync.RWMutex
	createFileGroupArgsForCall []struct {
		arg1 config.FileGroup
	}
	createFileGroupReturns struct {
		result1 *api.GroupResponse
		result2 error
	}
	createFileGroupReturnsOnCall map[int]struct {
		result1 *api.GroupResponse
		result2 error
	}
	CreateProductFileStub        func(config.ProductFile) (*api.ProductFileResponse, error)
	createProductFileMutex       sync.RWMutex
	createProductFileArgsForCall []struct {
		arg1 config.ProductFile
	}
	createProductFileReturns struct {
		result1 *api.ProductFileResponse
		result2 error
	}
	createProductFileReturnsOnCall map[int]struct {
		result1 *api.ProductFileResponse
		result2 error
	}
	CreateReleaseStub        func(config.Release) (*api.ReleaseResponse, error)
	createReleaseMutex       sync.RWMutex
	createReleaseArgsForCall []struct {
		arg1 config.Release
	}
	createReleaseReturns struct {
		result1 *api.ReleaseResponse
		result2 error
	}
	createReleaseReturnsOnCall map[int]struct {
		result1 *api.ReleaseResponse
		result2 error
	}
	DeleteProductFileStub        func(int64) (*api.ProductFileResponse, error)
	deleteProductFileMutex       sync.RWMutex
	deleteProductFileArgsForCall []struct {
		arg1 int64
	}
	deleteProductFileReturns struct {
		result1 *api.ProductFileResponse
		result2 error
	}
	deleteProductFileReturnsOnCall map[int]struct {
		result1 *api.ProductFileResponse
		result2 error
	}
	GetAllReleasesStub        func() (*api.ReleaseArrayResponse, error)
	getAllReleasesMutex       sync.RWMutex
	getAllReleasesArgsForCall []struct {
	}
	getAllReleasesReturns struct {
		result1 *api.ReleaseArrayResponse
		result2 error
	}
	getAllReleasesReturnsOnCall map[int]struct {
		result1 *api.ReleaseArrayResponse
		result2 error
	}
	GetPreviousReleaseStub        func(int, string) (*config.Release, error)
	getPreviousReleaseMutex       sync.RWMutex
	getPreviousReleaseArgsForCall []struct {
		arg1 int
		arg2 string
	}
	getPreviousReleaseReturns struct {
		result1 *config.Release
		result2 error
	}
	getPreviousReleaseReturnsOnCall map[int]struct {
		result1 *config.Release
		result2 error
	}
	GetProductFileStub        func(int64) (*api.ProductFileResponse, error)
	getProductFileMutex       sync.RWMutex
	getProductFileArgsForCall []struct {
		arg1 int64
	}
	getProductFileReturns struct {
		result1 *api.ProductFileResponse
		result2 error
	}
	getProductFileReturnsOnCall map[int]struct {
		result1 *api.ProductFileResponse
		result2 error
	}
	IsProductFileTransferInProgressStub        func(int64) bool
	isProductFileTransferInProgressMutex       sync.RWMutex
	isProductFileTransferInProgressArgsForCall []struct {
		arg1 int64
	}
	isProductFileTransferInProgressReturns struct {
		result1 bool
	}
	isProductFileTransferInProgressReturnsOnCall map[int]struct {
		result1 bool
	}
	UpdateReleaseStub        func(config.Release) (*api.ReleaseResponse, error)
	updateReleaseMutex       sync.RWMutex
	updateReleaseArgsForCall []struct {
		arg1 config.Release
	}
	updateReleaseReturns struct {
		result1 *api.ReleaseResponse
		result2 error
	}
	updateReleaseReturnsOnCall map[int]struct {
		result1 *api.ReleaseResponse
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeAccessInterface) AddProductFileToFileGroup(arg1 int64, arg2 int64) error {
	fake.addProductFileToFileGroupMutex.Lock()
	ret, specificReturn := fake.addProductFileToFileGroupReturnsOnCall[len(fake.addProductFileToFileGroupArgsForCall)]
	fake.addProductFileToFileGroupArgsForCall = append(fake.addProductFileToFileGroupArgsForCall, struct {
		arg1 int64
		arg2 int64
	}{arg1, arg2})
	fake.recordInvocation("AddProductFileToFileGroup", []interface{}{arg1, arg2})
	fake.addProductFileToFileGroupMutex.Unlock()
	if fake.AddProductFileToFileGroupStub != nil {
		return fake.AddProductFileToFileGroupStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.addProductFileToFileGroupReturns
	return fakeReturns.result1
}

func (fake *FakeAccessInterface) AddProductFileToFileGroupCallCount() int {
	fake.addProductFileToFileGroupMutex.RLock()
	defer fake.addProductFileToFileGroupMutex.RUnlock()
	return len(fake.addProductFileToFileGroupArgsForCall)
}

func (fake *FakeAccessInterface) AddProductFileToFileGroupCalls(stub func(int64, int64) error) {
	fake.addProductFileToFileGroupMutex.Lock()
	defer fake.addProductFileToFileGroupMutex.Unlock()
	fake.AddProductFileToFileGroupStub = stub
}

func (fake *FakeAccessInterface) AddProductFileToFileGroupArgsForCall(i int) (int64, int64) {
	fake.addProductFileToFileGroupMutex.RLock()
	defer fake.addProductFileToFileGroupMutex.RUnlock()
	argsForCall := fake.addProductFileToFileGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAccessInterface) AddProductFileToFileGroupReturns(result1 error) {
	fake.addProductFileToFileGroupMutex.Lock()
	defer fake.addProductFileToFileGroupMutex.Unlock()
	fake.AddProductFileToFileGroupStub = nil
	fake.addProductFileToFileGroupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAccessInterface) AddProductFileToFileGroupReturnsOnCall(i int, result1 error) {
	fake.addProductFileToFileGroupMutex.Lock()
	defer fake.addProductFileToFileGroupMutex.Unlock()
	fake.AddProductFileToFileGroupStub = nil
	if fake.addProductFileToFileGroupReturnsOnCall == nil {
		fake.addProductFileToFileGroupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addProductFileToFileGroupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAccessInterface) AddProductFileToRelease(arg1 int64, arg2 int64) error {
	fake.addProductFileToReleaseMutex.Lock()
	ret, specificReturn := fake.addProductFileToReleaseReturnsOnCall[len(fake.addProductFileToReleaseArgsForCall)]
	fake.addProductFileToReleaseArgsForCall = append(fake.addProductFileToReleaseArgsForCall, struct {
		arg1 int64
		arg2 int64
	}{arg1, arg2})
	fake.recordInvocation("AddProductFileToRelease", []interface{}{arg1, arg2})
	fake.addProductFileToReleaseMutex.Unlock()
	if fake.AddProductFileToReleaseStub != nil {
		return fake.AddProductFileToReleaseStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.addProductFileToReleaseReturns
	return fakeReturns.result1
}

func (fake *FakeAccessInterface) AddProductFileToReleaseCallCount() int {
	fake.addProductFileToReleaseMutex.RLock()
	defer fake.addProductFileToReleaseMutex.RUnlock()
	return len(fake.addProductFileToReleaseArgsForCall)
}

func (fake *FakeAccessInterface) AddProductFileToReleaseCalls(stub func(int64, int64) error) {
	fake.addProductFileToReleaseMutex.Lock()
	defer fake.addProductFileToReleaseMutex.Unlock()
	fake.AddProductFileToReleaseStub = stub
}

func (fake *FakeAccessInterface) AddProductFileToReleaseArgsForCall(i int) (int64, int64) {
	fake.addProductFileToReleaseMutex.RLock()
	defer fake.addProductFileToReleaseMutex.RUnlock()
	argsForCall := fake.addProductFileToReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAccessInterface) AddProductFileToReleaseReturns(result1 error) {
	fake.addProductFileToReleaseMutex.Lock()
	defer fake.addProductFileToReleaseMutex.Unlock()
	fake.AddProductFileToReleaseStub = nil
	fake.addProductFileToReleaseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAccessInterface) AddProductFileToReleaseReturnsOnCall(i int, result1 error) {
	fake.addProductFileToReleaseMutex.Lock()
	defer fake.addProductFileToReleaseMutex.Unlock()
	fake.AddProductFileToReleaseStub = nil
	if fake.addProductFileToReleaseReturnsOnCall == nil {
		fake.addProductFileToReleaseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addProductFileToReleaseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAccessInterface) CreateFederationToken() (*api.FederationTokenResponse, error) {
	fake.createFederationTokenMutex.Lock()
	ret, specificReturn := fake.createFederationTokenReturnsOnCall[len(fake.createFederationTokenArgsForCall)]
	fake.createFederationTokenArgsForCall = append(fake.createFederationTokenArgsForCall, struct {
	}{})
	fake.recordInvocation("CreateFederationToken", []interface{}{})
	fake.createFederationTokenMutex.Unlock()
	if fake.CreateFederationTokenStub != nil {
		return fake.CreateFederationTokenStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createFederationTokenReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccessInterface) CreateFederationTokenCallCount() int {
	fake.createFederationTokenMutex.RLock()
	defer fake.createFederationTokenMutex.RUnlock()
	return len(fake.createFederationTokenArgsForCall)
}

func (fake *FakeAccessInterface) CreateFederationTokenCalls(stub func() (*api.FederationTokenResponse, error)) {
	fake.createFederationTokenMutex.Lock()
	defer fake.createFederationTokenMutex.Unlock()
	fake.CreateFederationTokenStub = stub
}

func (fake *FakeAccessInterface) CreateFederationTokenReturns(result1 *api.FederationTokenResponse, result2 error) {
	fake.createFederationTokenMutex.Lock()
	defer fake.createFederationTokenMutex.Unlock()
	fake.CreateFederationTokenStub = nil
	fake.createFederationTokenReturns = struct {
		result1 *api.FederationTokenResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessInterface) CreateFederationTokenReturnsOnCall(i int, result1 *api.FederationTokenResponse, result2 error) {
	fake.createFederationTokenMutex.Lock()
	defer fake.createFederationTokenMutex.Unlock()
	fake.CreateFederationTokenStub = nil
	if fake.createFederationTokenReturnsOnCall == nil {
		fake.createFederationTokenReturnsOnCall = make(map[int]struct {
			result1 *api.FederationTokenResponse
			result2 error
		})
	}
	fake.createFederationTokenReturnsOnCall[i] = struct {
		result1 *api.FederationTokenResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessInterface) CreateFileGroup(arg1 config.FileGroup) (*api.GroupResponse, error) {
	fake.createFileGroupMutex.Lock()
	ret, specificReturn := fake.createFileGroupReturnsOnCall[len(fake.createFileGroupArgsForCall)]
	fake.createFileGroupArgsForCall = append(fake.createFileGroupArgsForCall, struct {
		arg1 config.FileGroup
	}{arg1})
	fake.recordInvocation("CreateFileGroup", []interface{}{arg1})
	fake.createFileGroupMutex.Unlock()
	if fake.CreateFileGroupStub != nil {
		return fake.CreateFileGroupStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createFileGroupReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccessInterface) CreateFileGroupCallCount() int {
	fake.createFileGroupMutex.RLock()
	defer fake.createFileGroupMutex.RUnlock()
	return len(fake.createFileGroupArgsForCall)
}

func (fake *FakeAccessInterface) CreateFileGroupCalls(stub func(config.FileGroup) (*api.GroupResponse, error)) {
	fake.createFileGroupMutex.Lock()
	defer fake.createFileGroupMutex.Unlock()
	fake.CreateFileGroupStub = stub
}

func (fake *FakeAccessInterface) CreateFileGroupArgsForCall(i int) config.FileGroup {
	fake.createFileGroupMutex.RLock()
	defer fake.createFileGroupMutex.RUnlock()
	argsForCall := fake.createFileGroupArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccessInterface) CreateFileGroupReturns(result1 *api.GroupResponse, result2 error) {
	fake.createFileGroupMutex.Lock()
	defer fake.createFileGroupMutex.Unlock()
	fake.CreateFileGroupStub = nil
	fake.createFileGroupReturns = struct {
		result1 *api.GroupResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessInterface) CreateFileGroupReturnsOnCall(i int, result1 *api.GroupResponse, result2 error) {
	fake.createFileGroupMutex.Lock()
	defer fake.createFileGroupMutex.Unlock()
	fake.CreateFileGroupStub = nil
	if fake.createFileGroupReturnsOnCall == nil {
		fake.createFileGroupReturnsOnCall = make(map[int]struct {
			result1 *api.GroupResponse
			result2 error
		})
	}
	fake.createFileGroupReturnsOnCall[i] = struct {
		result1 *api.GroupResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessInterface) CreateProductFile(arg1 config.ProductFile) (*api.ProductFileResponse, error) {
	fake.createProductFileMutex.Lock()
	ret, specificReturn := fake.createProductFileReturnsOnCall[len(fake.createProductFileArgsForCall)]
	fake.createProductFileArgsForCall = append(fake.createProductFileArgsForCall, struct {
		arg1 config.ProductFile
	}{arg1})
	fake.recordInvocation("CreateProductFile", []interface{}{arg1})
	fake.createProductFileMutex.Unlock()
	if fake.CreateProductFileStub != nil {
		return fake.CreateProductFileStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createProductFileReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccessInterface) CreateProductFileCallCount() int {
	fake.createProductFileMutex.RLock()
	defer fake.createProductFileMutex.RUnlock()
	return len(fake.createProductFileArgsForCall)
}

func (fake *FakeAccessInterface) CreateProductFileCalls(stub func(config.ProductFile) (*api.ProductFileResponse, error)) {
	fake.createProductFileMutex.Lock()
	defer fake.createProductFileMutex.Unlock()
	fake.CreateProductFileStub = stub
}

func (fake *FakeAccessInterface) CreateProductFileArgsForCall(i int) config.ProductFile {
	fake.createProductFileMutex.RLock()
	defer fake.createProductFileMutex.RUnlock()
	argsForCall := fake.createProductFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccessInterface) CreateProductFileReturns(result1 *api.ProductFileResponse, result2 error) {
	fake.createProductFileMutex.Lock()
	defer fake.createProductFileMutex.Unlock()
	fake.CreateProductFileStub = nil
	fake.createProductFileReturns = struct {
		result1 *api.ProductFileResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessInterface) CreateProductFileReturnsOnCall(i int, result1 *api.ProductFileResponse, result2 error) {
	fake.createProductFileMutex.Lock()
	defer fake.createProductFileMutex.Unlock()
	fake.CreateProductFileStub = nil
	if fake.createProductFileReturnsOnCall == nil {
		fake.createProductFileReturnsOnCall = make(map[int]struct {
			result1 *api.ProductFileResponse
			result2 error
		})
	}
	fake.createProductFileReturnsOnCall[i] = struct {
		result1 *api.ProductFileResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessInterface) CreateRelease(arg1 config.Release) (*api.ReleaseResponse, error) {
	fake.createReleaseMutex.Lock()
	ret, specificReturn := fake.createReleaseReturnsOnCall[len(fake.createReleaseArgsForCall)]
	fake.createReleaseArgsForCall = append(fake.createReleaseArgsForCall, struct {
		arg1 config.Release
	}{arg1})
	fake.recordInvocation("CreateRelease", []interface{}{arg1})
	fake.createReleaseMutex.Unlock()
	if fake.CreateReleaseStub != nil {
		return fake.CreateReleaseStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createReleaseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccessInterface) CreateReleaseCallCount() int {
	fake.createReleaseMutex.RLock()
	defer fake.createReleaseMutex.RUnlock()
	return len(fake.createReleaseArgsForCall)
}

func (fake *FakeAccessInterface) CreateReleaseCalls(stub func(config.Release) (*api.ReleaseResponse, error)) {
	fake.createReleaseMutex.Lock()
	defer fake.createReleaseMutex.Unlock()
	fake.CreateReleaseStub = stub
}

func (fake *FakeAccessInterface) CreateReleaseArgsForCall(i int) config.Release {
	fake.createReleaseMutex.RLock()
	defer fake.createReleaseMutex.RUnlock()
	argsForCall := fake.createReleaseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccessInterface) CreateReleaseReturns(result1 *api.ReleaseResponse, result2 error) {
	fake.createReleaseMutex.Lock()
	defer fake.createReleaseMutex.Unlock()
	fake.CreateReleaseStub = nil
	fake.createReleaseReturns = struct {
		result1 *api.ReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessInterface) CreateReleaseReturnsOnCall(i int, result1 *api.ReleaseResponse, result2 error) {
	fake.createReleaseMutex.Lock()
	defer fake.createReleaseMutex.Unlock()
	fake.CreateReleaseStub = nil
	if fake.createReleaseReturnsOnCall == nil {
		fake.createReleaseReturnsOnCall = make(map[int]struct {
			result1 *api.ReleaseResponse
			result2 error
		})
	}
	fake.createReleaseReturnsOnCall[i] = struct {
		result1 *api.ReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessInterface) DeleteProductFile(arg1 int64) (*api.ProductFileResponse, error) {
	fake.deleteProductFileMutex.Lock()
	ret, specificReturn := fake.deleteProductFileReturnsOnCall[len(fake.deleteProductFileArgsForCall)]
	fake.deleteProductFileArgsForCall = append(fake.deleteProductFileArgsForCall, struct {
		arg1 int64
	}{arg1})
	fake.recordInvocation("DeleteProductFile", []interface{}{arg1})
	fake.deleteProductFileMutex.Unlock()
	if fake.DeleteProductFileStub != nil {
		return fake.DeleteProductFileStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteProductFileReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccessInterface) DeleteProductFileCallCount() int {
	fake.deleteProductFileMutex.RLock()
	defer fake.deleteProductFileMutex.RUnlock()
	return len(fake.deleteProductFileArgsForCall)
}

func (fake *FakeAccessInterface) DeleteProductFileCalls(stub func(int64) (*api.ProductFileResponse, error)) {
	fake.deleteProductFileMutex.Lock()
	defer fake.deleteProductFileMutex.Unlock()
	fake.DeleteProductFileStub = stub
}

func (fake *FakeAccessInterface) DeleteProductFileArgsForCall(i int) int64 {
	fake.deleteProductFileMutex.RLock()
	defer fake.deleteProductFileMutex.RUnlock()
	argsForCall := fake.deleteProductFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccessInterface) DeleteProductFileReturns(result1 *api.ProductFileResponse, result2 error) {
	fake.deleteProductFileMutex.Lock()
	defer fake.deleteProductFileMutex.Unlock()
	fake.DeleteProductFileStub = nil
	fake.deleteProductFileReturns = struct {
		result1 *api.ProductFileResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessInterface) DeleteProductFileReturnsOnCall(i int, result1 *api.ProductFileResponse, result2 error) {
	fake.deleteProductFileMutex.Lock()
	defer fake.deleteProductFileMutex.Unlock()
	fake.DeleteProductFileStub = nil
	if fake.deleteProductFileReturnsOnCall == nil {
		fake.deleteProductFileReturnsOnCall = make(map[int]struct {
			result1 *api.ProductFileResponse
			result2 error
		})
	}
	fake.deleteProductFileReturnsOnCall[i] = struct {
		result1 *api.ProductFileResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessInterface) GetAllReleases() (*api.ReleaseArrayResponse, error) {
	fake.getAllReleasesMutex.Lock()
	ret, specificReturn := fake.getAllReleasesReturnsOnCall[len(fake.getAllReleasesArgsForCall)]
	fake.getAllReleasesArgsForCall = append(fake.getAllReleasesArgsForCall, struct {
	}{})
	fake.recordInvocation("GetAllReleases", []interface{}{})
	fake.getAllReleasesMutex.Unlock()
	if fake.GetAllReleasesStub != nil {
		return fake.GetAllReleasesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getAllReleasesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccessInterface) GetAllReleasesCallCount() int {
	fake.getAllReleasesMutex.RLock()
	defer fake.getAllReleasesMutex.RUnlock()
	return len(fake.getAllReleasesArgsForCall)
}

func (fake *FakeAccessInterface) GetAllReleasesCalls(stub func() (*api.ReleaseArrayResponse, error)) {
	fake.getAllReleasesMutex.Lock()
	defer fake.getAllReleasesMutex.Unlock()
	fake.GetAllReleasesStub = stub
}

func (fake *FakeAccessInterface) GetAllReleasesReturns(result1 *api.ReleaseArrayResponse, result2 error) {
	fake.getAllReleasesMutex.Lock()
	defer fake.getAllReleasesMutex.Unlock()
	fake.GetAllReleasesStub = nil
	fake.getAllReleasesReturns = struct {
		result1 *api.ReleaseArrayResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessInterface) GetAllReleasesReturnsOnCall(i int, result1 *api.ReleaseArrayResponse, result2 error) {
	fake.getAllReleasesMutex.Lock()
	defer fake.getAllReleasesMutex.Unlock()
	fake.GetAllReleasesStub = nil
	if fake.getAllReleasesReturnsOnCall == nil {
		fake.getAllReleasesReturnsOnCall = make(map[int]struct {
			result1 *api.ReleaseArrayResponse
			result2 error
		})
	}
	fake.getAllReleasesReturnsOnCall[i] = struct {
		result1 *api.ReleaseArrayResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessInterface) GetPreviousRelease(arg1 int, arg2 string) (*config.Release, error) {
	fake.getPreviousReleaseMutex.Lock()
	ret, specificReturn := fake.getPreviousReleaseReturnsOnCall[len(fake.getPreviousReleaseArgsForCall)]
	fake.getPreviousReleaseArgsForCall = append(fake.getPreviousReleaseArgsForCall, struct {
		arg1 int
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("GetPreviousRelease", []interface{}{arg1, arg2})
	fake.getPreviousReleaseMutex.Unlock()
	if fake.GetPreviousReleaseStub != nil {
		return fake.GetPreviousReleaseStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getPreviousReleaseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccessInterface) GetPreviousReleaseCallCount() int {
	fake.getPreviousReleaseMutex.RLock()
	defer fake.getPreviousReleaseMutex.RUnlock()
	return len(fake.getPreviousReleaseArgsForCall)
}

func (fake *FakeAccessInterface) GetPreviousReleaseCalls(stub func(int, string) (*config.Release, error)) {
	fake.getPreviousReleaseMutex.Lock()
	defer fake.getPreviousReleaseMutex.Unlock()
	fake.GetPreviousReleaseStub = stub
}

func (fake *FakeAccessInterface) GetPreviousReleaseArgsForCall(i int) (int, string) {
	fake.getPreviousReleaseMutex.RLock()
	defer fake.getPreviousReleaseMutex.RUnlock()
	argsForCall := fake.getPreviousReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAccessInterface) GetPreviousReleaseReturns(result1 *config.Release, result2 error) {
	fake.getPreviousReleaseMutex.Lock()
	defer fake.getPreviousReleaseMutex.Unlock()
	fake.GetPreviousReleaseStub = nil
	fake.getPreviousReleaseReturns = struct {
		result1 *config.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessInterface) GetPreviousReleaseReturnsOnCall(i int, result1 *config.Release, result2 error) {
	fake.getPreviousReleaseMutex.Lock()
	defer fake.getPreviousReleaseMutex.Unlock()
	fake.GetPreviousReleaseStub = nil
	if fake.getPreviousReleaseReturnsOnCall == nil {
		fake.getPreviousReleaseReturnsOnCall = make(map[int]struct {
			result1 *config.Release
			result2 error
		})
	}
	fake.getPreviousReleaseReturnsOnCall[i] = struct {
		result1 *config.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessInterface) GetProductFile(arg1 int64) (*api.ProductFileResponse, error) {
	fake.getProductFileMutex.Lock()
	ret, specificReturn := fake.getProductFileReturnsOnCall[len(fake.getProductFileArgsForCall)]
	fake.getProductFileArgsForCall = append(fake.getProductFileArgsForCall, struct {
		arg1 int64
	}{arg1})
	fake.recordInvocation("GetProductFile", []interface{}{arg1})
	fake.getProductFileMutex.Unlock()
	if fake.GetProductFileStub != nil {
		return fake.GetProductFileStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getProductFileReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccessInterface) GetProductFileCallCount() int {
	fake.getProductFileMutex.RLock()
	defer fake.getProductFileMutex.RUnlock()
	return len(fake.getProductFileArgsForCall)
}

func (fake *FakeAccessInterface) GetProductFileCalls(stub func(int64) (*api.ProductFileResponse, error)) {
	fake.getProductFileMutex.Lock()
	defer fake.getProductFileMutex.Unlock()
	fake.GetProductFileStub = stub
}

func (fake *FakeAccessInterface) GetProductFileArgsForCall(i int) int64 {
	fake.getProductFileMutex.RLock()
	defer fake.getProductFileMutex.RUnlock()
	argsForCall := fake.getProductFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccessInterface) GetProductFileReturns(result1 *api.ProductFileResponse, result2 error) {
	fake.getProductFileMutex.Lock()
	defer fake.getProductFileMutex.Unlock()
	fake.GetProductFileStub = nil
	fake.getProductFileReturns = struct {
		result1 *api.ProductFileResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessInterface) GetProductFileReturnsOnCall(i int, result1 *api.ProductFileResponse, result2 error) {
	fake.getProductFileMutex.Lock()
	defer fake.getProductFileMutex.Unlock()
	fake.GetProductFileStub = nil
	if fake.getProductFileReturnsOnCall == nil {
		fake.getProductFileReturnsOnCall = make(map[int]struct {
			result1 *api.ProductFileResponse
			result2 error
		})
	}
	fake.getProductFileReturnsOnCall[i] = struct {
		result1 *api.ProductFileResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessInterface) IsProductFileTransferInProgress(arg1 int64) bool {
	fake.isProductFileTransferInProgressMutex.Lock()
	ret, specificReturn := fake.isProductFileTransferInProgressReturnsOnCall[len(fake.isProductFileTransferInProgressArgsForCall)]
	fake.isProductFileTransferInProgressArgsForCall = append(fake.isProductFileTransferInProgressArgsForCall, struct {
		arg1 int64
	}{arg1})
	fake.recordInvocation("IsProductFileTransferInProgress", []interface{}{arg1})
	fake.isProductFileTransferInProgressMutex.Unlock()
	if fake.IsProductFileTransferInProgressStub != nil {
		return fake.IsProductFileTransferInProgressStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.isProductFileTransferInProgressReturns
	return fakeReturns.result1
}

func (fake *FakeAccessInterface) IsProductFileTransferInProgressCallCount() int {
	fake.isProductFileTransferInProgressMutex.RLock()
	defer fake.isProductFileTransferInProgressMutex.RUnlock()
	return len(fake.isProductFileTransferInProgressArgsForCall)
}

func (fake *FakeAccessInterface) IsProductFileTransferInProgressCalls(stub func(int64) bool) {
	fake.isProductFileTransferInProgressMutex.Lock()
	defer fake.isProductFileTransferInProgressMutex.Unlock()
	fake.IsProductFileTransferInProgressStub = stub
}

func (fake *FakeAccessInterface) IsProductFileTransferInProgressArgsForCall(i int) int64 {
	fake.isProductFileTransferInProgressMutex.RLock()
	defer fake.isProductFileTransferInProgressMutex.RUnlock()
	argsForCall := fake.isProductFileTransferInProgressArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccessInterface) IsProductFileTransferInProgressReturns(result1 bool) {
	fake.isProductFileTransferInProgressMutex.Lock()
	defer fake.isProductFileTransferInProgressMutex.Unlock()
	fake.IsProductFileTransferInProgressStub = nil
	fake.isProductFileTransferInProgressReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeAccessInterface) IsProductFileTransferInProgressReturnsOnCall(i int, result1 bool) {
	fake.isProductFileTransferInProgressMutex.Lock()
	defer fake.isProductFileTransferInProgressMutex.Unlock()
	fake.IsProductFileTransferInProgressStub = nil
	if fake.isProductFileTransferInProgressReturnsOnCall == nil {
		fake.isProductFileTransferInProgressReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isProductFileTransferInProgressReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeAccessInterface) UpdateRelease(arg1 config.Release) (*api.ReleaseResponse, error) {
	fake.updateReleaseMutex.Lock()
	ret, specificReturn := fake.updateReleaseReturnsOnCall[len(fake.updateReleaseArgsForCall)]
	fake.updateReleaseArgsForCall = append(fake.updateReleaseArgsForCall, struct {
		arg1 config.Release
	}{arg1})
	fake.recordInvocation("UpdateRelease", []interface{}{arg1})
	fake.updateReleaseMutex.Unlock()
	if fake.UpdateReleaseStub != nil {
		return fake.UpdateReleaseStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateReleaseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccessInterface) UpdateReleaseCallCount() int {
	fake.updateReleaseMutex.RLock()
	defer fake.updateReleaseMutex.RUnlock()
	return len(fake.updateReleaseArgsForCall)
}

func (fake *FakeAccessInterface) UpdateReleaseCalls(stub func(config.Release) (*api.ReleaseResponse, error)) {
	fake.updateReleaseMutex.Lock()
	defer fake.updateReleaseMutex.Unlock()
	fake.UpdateReleaseStub = stub
}

func (fake *FakeAccessInterface) UpdateReleaseArgsForCall(i int) config.Release {
	fake.updateReleaseMutex.RLock()
	defer fake.updateReleaseMutex.RUnlock()
	argsForCall := fake.updateReleaseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccessInterface) UpdateReleaseReturns(result1 *api.ReleaseResponse, result2 error) {
	fake.updateReleaseMutex.Lock()
	defer fake.updateReleaseMutex.Unlock()
	fake.UpdateReleaseStub = nil
	fake.updateReleaseReturns = struct {
		result1 *api.ReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessInterface) UpdateReleaseReturnsOnCall(i int, result1 *api.ReleaseResponse, result2 error) {
	fake.updateReleaseMutex.Lock()
	defer fake.updateReleaseMutex.Unlock()
	fake.UpdateReleaseStub = nil
	if fake.updateReleaseReturnsOnCall == nil {
		fake.updateReleaseReturnsOnCall = make(map[int]struct {
			result1 *api.ReleaseResponse
			result2 error
		})
	}
	fake.updateReleaseReturnsOnCall[i] = struct {
		result1 *api.ReleaseResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessInterface) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addProductFileToFileGroupMutex.RLock()
	defer fake.addProductFileToFileGroupMutex.RUnlock()
	fake.addProductFileToReleaseMutex.RLock()
	defer fake.addProductFileToReleaseMutex.RUnlock()
	fake.createFederationTokenMutex.RLock()
	defer fake.createFederationTokenMutex.RUnlock()
	fake.createFileGroupMutex.RLock()
	defer fake.createFileGroupMutex.RUnlock()
	fake.createProductFileMutex.RLock()
	defer fake.createProductFileMutex.RUnlock()
	fake.createReleaseMutex.RLock()
	defer fake.createReleaseMutex.RUnlock()
	fake.deleteProductFileMutex.RLock()
	defer fake.deleteProductFileMutex.RUnlock()
	fake.getAllReleasesMutex.RLock()
	defer fake.getAllReleasesMutex.RUnlock()
	fake.getPreviousReleaseMutex.RLock()
	defer fake.getPreviousReleaseMutex.RUnlock()
	fake.getProductFileMutex.RLock()
	defer fake.getProductFileMutex.RUnlock()
	fake.isProductFileTransferInProgressMutex.RLock()
	defer fake.isProductFileTransferInProgressMutex.RUnlock()
	fake.updateReleaseMutex.RLock()
	defer fake.updateReleaseMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeAccessInterface) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ api.AccessInterface = new(FakeAccessInterface)
