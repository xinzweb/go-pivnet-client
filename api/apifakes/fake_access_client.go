// Code generated by counterfeiter. DO NOT EDIT.
package apifakes

import (
	"sync"

	"github.com/baotingfang/go-pivnet-client/api"
	pivnet "github.com/pivotal-cf/go-pivnet/v4"
)

type FakeAccessClient struct {
	AddFileGroupToReleaseStub        func(int, int) error
	addFileGroupToReleaseMutex       sync.RWMutex
	addFileGroupToReleaseArgsForCall []struct {
		arg1 int
		arg2 int
	}
	addFileGroupToReleaseReturns struct {
		result1 error
	}
	addFileGroupToReleaseReturnsOnCall map[int]struct {
		result1 error
	}
	AddProductFileToFileGroupStub        func(int, int) error
	addProductFileToFileGroupMutex       sync.RWMutex
	addProductFileToFileGroupArgsForCall []struct {
		arg1 int
		arg2 int
	}
	addProductFileToFileGroupReturns struct {
		result1 error
	}
	addProductFileToFileGroupReturnsOnCall map[int]struct {
		result1 error
	}
	AddProductFileToReleaseStub        func(int, int) error
	addProductFileToReleaseMutex       sync.RWMutex
	addProductFileToReleaseArgsForCall []struct {
		arg1 int
		arg2 int
	}
	addProductFileToReleaseReturns struct {
		result1 error
	}
	addProductFileToReleaseReturnsOnCall map[int]struct {
		result1 error
	}
	CreateFederationTokenStub        func() (pivnet.FederationToken, error)
	createFederationTokenMutex       sync.RWMutex
	createFederationTokenArgsForCall []struct {
	}
	createFederationTokenReturns struct {
		result1 pivnet.FederationToken
		result2 error
	}
	createFederationTokenReturnsOnCall map[int]struct {
		result1 pivnet.FederationToken
		result2 error
	}
	CreateFileGroupStub        func(string) (pivnet.FileGroup, error)
	createFileGroupMutex       sync.RWMutex
	createFileGroupArgsForCall []struct {
		arg1 string
	}
	createFileGroupReturns struct {
		result1 pivnet.FileGroup
		result2 error
	}
	createFileGroupReturnsOnCall map[int]struct {
		result1 pivnet.FileGroup
		result2 error
	}
	CreateProductFileStub        func(pivnet.CreateProductFileConfig) (pivnet.ProductFile, error)
	createProductFileMutex       sync.RWMutex
	createProductFileArgsForCall []struct {
		arg1 pivnet.CreateProductFileConfig
	}
	createProductFileReturns struct {
		result1 pivnet.ProductFile
		result2 error
	}
	createProductFileReturnsOnCall map[int]struct {
		result1 pivnet.ProductFile
		result2 error
	}
	CreateReleaseStub        func(pivnet.CreateReleaseConfig) (pivnet.Release, error)
	createReleaseMutex       sync.RWMutex
	createReleaseArgsForCall []struct {
		arg1 pivnet.CreateReleaseConfig
	}
	createReleaseReturns struct {
		result1 pivnet.Release
		result2 error
	}
	createReleaseReturnsOnCall map[int]struct {
		result1 pivnet.Release
		result2 error
	}
	DeleteProductFileStub        func(int) (pivnet.ProductFile, error)
	deleteProductFileMutex       sync.RWMutex
	deleteProductFileArgsForCall []struct {
		arg1 int
	}
	deleteProductFileReturns struct {
		result1 pivnet.ProductFile
		result2 error
	}
	deleteProductFileReturnsOnCall map[int]struct {
		result1 pivnet.ProductFile
		result2 error
	}
	FileTransferStatusInProgressStub        func(int) bool
	fileTransferStatusInProgressMutex       sync.RWMutex
	fileTransferStatusInProgressArgsForCall []struct {
		arg1 int
	}
	fileTransferStatusInProgressReturns struct {
		result1 bool
	}
	fileTransferStatusInProgressReturnsOnCall map[int]struct {
		result1 bool
	}
	GetAllReleasesStub        func() ([]pivnet.Release, error)
	getAllReleasesMutex       sync.RWMutex
	getAllReleasesArgsForCall []struct {
	}
	getAllReleasesReturns struct {
		result1 []pivnet.Release
		result2 error
	}
	getAllReleasesReturnsOnCall map[int]struct {
		result1 []pivnet.Release
		result2 error
	}
	GetLatestPublicReleaseByReleaseTypeStub        func(int, pivnet.ReleaseType) (pivnet.Release, error)
	getLatestPublicReleaseByReleaseTypeMutex       sync.RWMutex
	getLatestPublicReleaseByReleaseTypeArgsForCall []struct {
		arg1 int
		arg2 pivnet.ReleaseType
	}
	getLatestPublicReleaseByReleaseTypeReturns struct {
		result1 pivnet.Release
		result2 error
	}
	getLatestPublicReleaseByReleaseTypeReturnsOnCall map[int]struct {
		result1 pivnet.Release
		result2 error
	}
	UpdateReleaseStub        func(pivnet.Release) (pivnet.Release, error)
	updateReleaseMutex       sync.RWMutex
	updateReleaseArgsForCall []struct {
		arg1 pivnet.Release
	}
	updateReleaseReturns struct {
		result1 pivnet.Release
		result2 error
	}
	updateReleaseReturnsOnCall map[int]struct {
		result1 pivnet.Release
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeAccessClient) AddFileGroupToRelease(arg1 int, arg2 int) error {
	fake.addFileGroupToReleaseMutex.Lock()
	ret, specificReturn := fake.addFileGroupToReleaseReturnsOnCall[len(fake.addFileGroupToReleaseArgsForCall)]
	fake.addFileGroupToReleaseArgsForCall = append(fake.addFileGroupToReleaseArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("AddFileGroupToRelease", []interface{}{arg1, arg2})
	fake.addFileGroupToReleaseMutex.Unlock()
	if fake.AddFileGroupToReleaseStub != nil {
		return fake.AddFileGroupToReleaseStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.addFileGroupToReleaseReturns
	return fakeReturns.result1
}

func (fake *FakeAccessClient) AddFileGroupToReleaseCallCount() int {
	fake.addFileGroupToReleaseMutex.RLock()
	defer fake.addFileGroupToReleaseMutex.RUnlock()
	return len(fake.addFileGroupToReleaseArgsForCall)
}

func (fake *FakeAccessClient) AddFileGroupToReleaseCalls(stub func(int, int) error) {
	fake.addFileGroupToReleaseMutex.Lock()
	defer fake.addFileGroupToReleaseMutex.Unlock()
	fake.AddFileGroupToReleaseStub = stub
}

func (fake *FakeAccessClient) AddFileGroupToReleaseArgsForCall(i int) (int, int) {
	fake.addFileGroupToReleaseMutex.RLock()
	defer fake.addFileGroupToReleaseMutex.RUnlock()
	argsForCall := fake.addFileGroupToReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAccessClient) AddFileGroupToReleaseReturns(result1 error) {
	fake.addFileGroupToReleaseMutex.Lock()
	defer fake.addFileGroupToReleaseMutex.Unlock()
	fake.AddFileGroupToReleaseStub = nil
	fake.addFileGroupToReleaseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAccessClient) AddFileGroupToReleaseReturnsOnCall(i int, result1 error) {
	fake.addFileGroupToReleaseMutex.Lock()
	defer fake.addFileGroupToReleaseMutex.Unlock()
	fake.AddFileGroupToReleaseStub = nil
	if fake.addFileGroupToReleaseReturnsOnCall == nil {
		fake.addFileGroupToReleaseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addFileGroupToReleaseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAccessClient) AddProductFileToFileGroup(arg1 int, arg2 int) error {
	fake.addProductFileToFileGroupMutex.Lock()
	ret, specificReturn := fake.addProductFileToFileGroupReturnsOnCall[len(fake.addProductFileToFileGroupArgsForCall)]
	fake.addProductFileToFileGroupArgsForCall = append(fake.addProductFileToFileGroupArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("AddProductFileToFileGroup", []interface{}{arg1, arg2})
	fake.addProductFileToFileGroupMutex.Unlock()
	if fake.AddProductFileToFileGroupStub != nil {
		return fake.AddProductFileToFileGroupStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.addProductFileToFileGroupReturns
	return fakeReturns.result1
}

func (fake *FakeAccessClient) AddProductFileToFileGroupCallCount() int {
	fake.addProductFileToFileGroupMutex.RLock()
	defer fake.addProductFileToFileGroupMutex.RUnlock()
	return len(fake.addProductFileToFileGroupArgsForCall)
}

func (fake *FakeAccessClient) AddProductFileToFileGroupCalls(stub func(int, int) error) {
	fake.addProductFileToFileGroupMutex.Lock()
	defer fake.addProductFileToFileGroupMutex.Unlock()
	fake.AddProductFileToFileGroupStub = stub
}

func (fake *FakeAccessClient) AddProductFileToFileGroupArgsForCall(i int) (int, int) {
	fake.addProductFileToFileGroupMutex.RLock()
	defer fake.addProductFileToFileGroupMutex.RUnlock()
	argsForCall := fake.addProductFileToFileGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAccessClient) AddProductFileToFileGroupReturns(result1 error) {
	fake.addProductFileToFileGroupMutex.Lock()
	defer fake.addProductFileToFileGroupMutex.Unlock()
	fake.AddProductFileToFileGroupStub = nil
	fake.addProductFileToFileGroupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAccessClient) AddProductFileToFileGroupReturnsOnCall(i int, result1 error) {
	fake.addProductFileToFileGroupMutex.Lock()
	defer fake.addProductFileToFileGroupMutex.Unlock()
	fake.AddProductFileToFileGroupStub = nil
	if fake.addProductFileToFileGroupReturnsOnCall == nil {
		fake.addProductFileToFileGroupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addProductFileToFileGroupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAccessClient) AddProductFileToRelease(arg1 int, arg2 int) error {
	fake.addProductFileToReleaseMutex.Lock()
	ret, specificReturn := fake.addProductFileToReleaseReturnsOnCall[len(fake.addProductFileToReleaseArgsForCall)]
	fake.addProductFileToReleaseArgsForCall = append(fake.addProductFileToReleaseArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("AddProductFileToRelease", []interface{}{arg1, arg2})
	fake.addProductFileToReleaseMutex.Unlock()
	if fake.AddProductFileToReleaseStub != nil {
		return fake.AddProductFileToReleaseStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.addProductFileToReleaseReturns
	return fakeReturns.result1
}

func (fake *FakeAccessClient) AddProductFileToReleaseCallCount() int {
	fake.addProductFileToReleaseMutex.RLock()
	defer fake.addProductFileToReleaseMutex.RUnlock()
	return len(fake.addProductFileToReleaseArgsForCall)
}

func (fake *FakeAccessClient) AddProductFileToReleaseCalls(stub func(int, int) error) {
	fake.addProductFileToReleaseMutex.Lock()
	defer fake.addProductFileToReleaseMutex.Unlock()
	fake.AddProductFileToReleaseStub = stub
}

func (fake *FakeAccessClient) AddProductFileToReleaseArgsForCall(i int) (int, int) {
	fake.addProductFileToReleaseMutex.RLock()
	defer fake.addProductFileToReleaseMutex.RUnlock()
	argsForCall := fake.addProductFileToReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAccessClient) AddProductFileToReleaseReturns(result1 error) {
	fake.addProductFileToReleaseMutex.Lock()
	defer fake.addProductFileToReleaseMutex.Unlock()
	fake.AddProductFileToReleaseStub = nil
	fake.addProductFileToReleaseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeAccessClient) AddProductFileToReleaseReturnsOnCall(i int, result1 error) {
	fake.addProductFileToReleaseMutex.Lock()
	defer fake.addProductFileToReleaseMutex.Unlock()
	fake.AddProductFileToReleaseStub = nil
	if fake.addProductFileToReleaseReturnsOnCall == nil {
		fake.addProductFileToReleaseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addProductFileToReleaseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeAccessClient) CreateFederationToken() (pivnet.FederationToken, error) {
	fake.createFederationTokenMutex.Lock()
	ret, specificReturn := fake.createFederationTokenReturnsOnCall[len(fake.createFederationTokenArgsForCall)]
	fake.createFederationTokenArgsForCall = append(fake.createFederationTokenArgsForCall, struct {
	}{})
	fake.recordInvocation("CreateFederationToken", []interface{}{})
	fake.createFederationTokenMutex.Unlock()
	if fake.CreateFederationTokenStub != nil {
		return fake.CreateFederationTokenStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createFederationTokenReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccessClient) CreateFederationTokenCallCount() int {
	fake.createFederationTokenMutex.RLock()
	defer fake.createFederationTokenMutex.RUnlock()
	return len(fake.createFederationTokenArgsForCall)
}

func (fake *FakeAccessClient) CreateFederationTokenCalls(stub func() (pivnet.FederationToken, error)) {
	fake.createFederationTokenMutex.Lock()
	defer fake.createFederationTokenMutex.Unlock()
	fake.CreateFederationTokenStub = stub
}

func (fake *FakeAccessClient) CreateFederationTokenReturns(result1 pivnet.FederationToken, result2 error) {
	fake.createFederationTokenMutex.Lock()
	defer fake.createFederationTokenMutex.Unlock()
	fake.CreateFederationTokenStub = nil
	fake.createFederationTokenReturns = struct {
		result1 pivnet.FederationToken
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessClient) CreateFederationTokenReturnsOnCall(i int, result1 pivnet.FederationToken, result2 error) {
	fake.createFederationTokenMutex.Lock()
	defer fake.createFederationTokenMutex.Unlock()
	fake.CreateFederationTokenStub = nil
	if fake.createFederationTokenReturnsOnCall == nil {
		fake.createFederationTokenReturnsOnCall = make(map[int]struct {
			result1 pivnet.FederationToken
			result2 error
		})
	}
	fake.createFederationTokenReturnsOnCall[i] = struct {
		result1 pivnet.FederationToken
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessClient) CreateFileGroup(arg1 string) (pivnet.FileGroup, error) {
	fake.createFileGroupMutex.Lock()
	ret, specificReturn := fake.createFileGroupReturnsOnCall[len(fake.createFileGroupArgsForCall)]
	fake.createFileGroupArgsForCall = append(fake.createFileGroupArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("CreateFileGroup", []interface{}{arg1})
	fake.createFileGroupMutex.Unlock()
	if fake.CreateFileGroupStub != nil {
		return fake.CreateFileGroupStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createFileGroupReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccessClient) CreateFileGroupCallCount() int {
	fake.createFileGroupMutex.RLock()
	defer fake.createFileGroupMutex.RUnlock()
	return len(fake.createFileGroupArgsForCall)
}

func (fake *FakeAccessClient) CreateFileGroupCalls(stub func(string) (pivnet.FileGroup, error)) {
	fake.createFileGroupMutex.Lock()
	defer fake.createFileGroupMutex.Unlock()
	fake.CreateFileGroupStub = stub
}

func (fake *FakeAccessClient) CreateFileGroupArgsForCall(i int) string {
	fake.createFileGroupMutex.RLock()
	defer fake.createFileGroupMutex.RUnlock()
	argsForCall := fake.createFileGroupArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccessClient) CreateFileGroupReturns(result1 pivnet.FileGroup, result2 error) {
	fake.createFileGroupMutex.Lock()
	defer fake.createFileGroupMutex.Unlock()
	fake.CreateFileGroupStub = nil
	fake.createFileGroupReturns = struct {
		result1 pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessClient) CreateFileGroupReturnsOnCall(i int, result1 pivnet.FileGroup, result2 error) {
	fake.createFileGroupMutex.Lock()
	defer fake.createFileGroupMutex.Unlock()
	fake.CreateFileGroupStub = nil
	if fake.createFileGroupReturnsOnCall == nil {
		fake.createFileGroupReturnsOnCall = make(map[int]struct {
			result1 pivnet.FileGroup
			result2 error
		})
	}
	fake.createFileGroupReturnsOnCall[i] = struct {
		result1 pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessClient) CreateProductFile(arg1 pivnet.CreateProductFileConfig) (pivnet.ProductFile, error) {
	fake.createProductFileMutex.Lock()
	ret, specificReturn := fake.createProductFileReturnsOnCall[len(fake.createProductFileArgsForCall)]
	fake.createProductFileArgsForCall = append(fake.createProductFileArgsForCall, struct {
		arg1 pivnet.CreateProductFileConfig
	}{arg1})
	fake.recordInvocation("CreateProductFile", []interface{}{arg1})
	fake.createProductFileMutex.Unlock()
	if fake.CreateProductFileStub != nil {
		return fake.CreateProductFileStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createProductFileReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccessClient) CreateProductFileCallCount() int {
	fake.createProductFileMutex.RLock()
	defer fake.createProductFileMutex.RUnlock()
	return len(fake.createProductFileArgsForCall)
}

func (fake *FakeAccessClient) CreateProductFileCalls(stub func(pivnet.CreateProductFileConfig) (pivnet.ProductFile, error)) {
	fake.createProductFileMutex.Lock()
	defer fake.createProductFileMutex.Unlock()
	fake.CreateProductFileStub = stub
}

func (fake *FakeAccessClient) CreateProductFileArgsForCall(i int) pivnet.CreateProductFileConfig {
	fake.createProductFileMutex.RLock()
	defer fake.createProductFileMutex.RUnlock()
	argsForCall := fake.createProductFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccessClient) CreateProductFileReturns(result1 pivnet.ProductFile, result2 error) {
	fake.createProductFileMutex.Lock()
	defer fake.createProductFileMutex.Unlock()
	fake.CreateProductFileStub = nil
	fake.createProductFileReturns = struct {
		result1 pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessClient) CreateProductFileReturnsOnCall(i int, result1 pivnet.ProductFile, result2 error) {
	fake.createProductFileMutex.Lock()
	defer fake.createProductFileMutex.Unlock()
	fake.CreateProductFileStub = nil
	if fake.createProductFileReturnsOnCall == nil {
		fake.createProductFileReturnsOnCall = make(map[int]struct {
			result1 pivnet.ProductFile
			result2 error
		})
	}
	fake.createProductFileReturnsOnCall[i] = struct {
		result1 pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessClient) CreateRelease(arg1 pivnet.CreateReleaseConfig) (pivnet.Release, error) {
	fake.createReleaseMutex.Lock()
	ret, specificReturn := fake.createReleaseReturnsOnCall[len(fake.createReleaseArgsForCall)]
	fake.createReleaseArgsForCall = append(fake.createReleaseArgsForCall, struct {
		arg1 pivnet.CreateReleaseConfig
	}{arg1})
	fake.recordInvocation("CreateRelease", []interface{}{arg1})
	fake.createReleaseMutex.Unlock()
	if fake.CreateReleaseStub != nil {
		return fake.CreateReleaseStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createReleaseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccessClient) CreateReleaseCallCount() int {
	fake.createReleaseMutex.RLock()
	defer fake.createReleaseMutex.RUnlock()
	return len(fake.createReleaseArgsForCall)
}

func (fake *FakeAccessClient) CreateReleaseCalls(stub func(pivnet.CreateReleaseConfig) (pivnet.Release, error)) {
	fake.createReleaseMutex.Lock()
	defer fake.createReleaseMutex.Unlock()
	fake.CreateReleaseStub = stub
}

func (fake *FakeAccessClient) CreateReleaseArgsForCall(i int) pivnet.CreateReleaseConfig {
	fake.createReleaseMutex.RLock()
	defer fake.createReleaseMutex.RUnlock()
	argsForCall := fake.createReleaseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccessClient) CreateReleaseReturns(result1 pivnet.Release, result2 error) {
	fake.createReleaseMutex.Lock()
	defer fake.createReleaseMutex.Unlock()
	fake.CreateReleaseStub = nil
	fake.createReleaseReturns = struct {
		result1 pivnet.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessClient) CreateReleaseReturnsOnCall(i int, result1 pivnet.Release, result2 error) {
	fake.createReleaseMutex.Lock()
	defer fake.createReleaseMutex.Unlock()
	fake.CreateReleaseStub = nil
	if fake.createReleaseReturnsOnCall == nil {
		fake.createReleaseReturnsOnCall = make(map[int]struct {
			result1 pivnet.Release
			result2 error
		})
	}
	fake.createReleaseReturnsOnCall[i] = struct {
		result1 pivnet.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessClient) DeleteProductFile(arg1 int) (pivnet.ProductFile, error) {
	fake.deleteProductFileMutex.Lock()
	ret, specificReturn := fake.deleteProductFileReturnsOnCall[len(fake.deleteProductFileArgsForCall)]
	fake.deleteProductFileArgsForCall = append(fake.deleteProductFileArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("DeleteProductFile", []interface{}{arg1})
	fake.deleteProductFileMutex.Unlock()
	if fake.DeleteProductFileStub != nil {
		return fake.DeleteProductFileStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteProductFileReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccessClient) DeleteProductFileCallCount() int {
	fake.deleteProductFileMutex.RLock()
	defer fake.deleteProductFileMutex.RUnlock()
	return len(fake.deleteProductFileArgsForCall)
}

func (fake *FakeAccessClient) DeleteProductFileCalls(stub func(int) (pivnet.ProductFile, error)) {
	fake.deleteProductFileMutex.Lock()
	defer fake.deleteProductFileMutex.Unlock()
	fake.DeleteProductFileStub = stub
}

func (fake *FakeAccessClient) DeleteProductFileArgsForCall(i int) int {
	fake.deleteProductFileMutex.RLock()
	defer fake.deleteProductFileMutex.RUnlock()
	argsForCall := fake.deleteProductFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccessClient) DeleteProductFileReturns(result1 pivnet.ProductFile, result2 error) {
	fake.deleteProductFileMutex.Lock()
	defer fake.deleteProductFileMutex.Unlock()
	fake.DeleteProductFileStub = nil
	fake.deleteProductFileReturns = struct {
		result1 pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessClient) DeleteProductFileReturnsOnCall(i int, result1 pivnet.ProductFile, result2 error) {
	fake.deleteProductFileMutex.Lock()
	defer fake.deleteProductFileMutex.Unlock()
	fake.DeleteProductFileStub = nil
	if fake.deleteProductFileReturnsOnCall == nil {
		fake.deleteProductFileReturnsOnCall = make(map[int]struct {
			result1 pivnet.ProductFile
			result2 error
		})
	}
	fake.deleteProductFileReturnsOnCall[i] = struct {
		result1 pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessClient) FileTransferStatusInProgress(arg1 int) bool {
	fake.fileTransferStatusInProgressMutex.Lock()
	ret, specificReturn := fake.fileTransferStatusInProgressReturnsOnCall[len(fake.fileTransferStatusInProgressArgsForCall)]
	fake.fileTransferStatusInProgressArgsForCall = append(fake.fileTransferStatusInProgressArgsForCall, struct {
		arg1 int
	}{arg1})
	fake.recordInvocation("FileTransferStatusInProgress", []interface{}{arg1})
	fake.fileTransferStatusInProgressMutex.Unlock()
	if fake.FileTransferStatusInProgressStub != nil {
		return fake.FileTransferStatusInProgressStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.fileTransferStatusInProgressReturns
	return fakeReturns.result1
}

func (fake *FakeAccessClient) FileTransferStatusInProgressCallCount() int {
	fake.fileTransferStatusInProgressMutex.RLock()
	defer fake.fileTransferStatusInProgressMutex.RUnlock()
	return len(fake.fileTransferStatusInProgressArgsForCall)
}

func (fake *FakeAccessClient) FileTransferStatusInProgressCalls(stub func(int) bool) {
	fake.fileTransferStatusInProgressMutex.Lock()
	defer fake.fileTransferStatusInProgressMutex.Unlock()
	fake.FileTransferStatusInProgressStub = stub
}

func (fake *FakeAccessClient) FileTransferStatusInProgressArgsForCall(i int) int {
	fake.fileTransferStatusInProgressMutex.RLock()
	defer fake.fileTransferStatusInProgressMutex.RUnlock()
	argsForCall := fake.fileTransferStatusInProgressArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccessClient) FileTransferStatusInProgressReturns(result1 bool) {
	fake.fileTransferStatusInProgressMutex.Lock()
	defer fake.fileTransferStatusInProgressMutex.Unlock()
	fake.FileTransferStatusInProgressStub = nil
	fake.fileTransferStatusInProgressReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeAccessClient) FileTransferStatusInProgressReturnsOnCall(i int, result1 bool) {
	fake.fileTransferStatusInProgressMutex.Lock()
	defer fake.fileTransferStatusInProgressMutex.Unlock()
	fake.FileTransferStatusInProgressStub = nil
	if fake.fileTransferStatusInProgressReturnsOnCall == nil {
		fake.fileTransferStatusInProgressReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.fileTransferStatusInProgressReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeAccessClient) GetAllReleases() ([]pivnet.Release, error) {
	fake.getAllReleasesMutex.Lock()
	ret, specificReturn := fake.getAllReleasesReturnsOnCall[len(fake.getAllReleasesArgsForCall)]
	fake.getAllReleasesArgsForCall = append(fake.getAllReleasesArgsForCall, struct {
	}{})
	fake.recordInvocation("GetAllReleases", []interface{}{})
	fake.getAllReleasesMutex.Unlock()
	if fake.GetAllReleasesStub != nil {
		return fake.GetAllReleasesStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getAllReleasesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccessClient) GetAllReleasesCallCount() int {
	fake.getAllReleasesMutex.RLock()
	defer fake.getAllReleasesMutex.RUnlock()
	return len(fake.getAllReleasesArgsForCall)
}

func (fake *FakeAccessClient) GetAllReleasesCalls(stub func() ([]pivnet.Release, error)) {
	fake.getAllReleasesMutex.Lock()
	defer fake.getAllReleasesMutex.Unlock()
	fake.GetAllReleasesStub = stub
}

func (fake *FakeAccessClient) GetAllReleasesReturns(result1 []pivnet.Release, result2 error) {
	fake.getAllReleasesMutex.Lock()
	defer fake.getAllReleasesMutex.Unlock()
	fake.GetAllReleasesStub = nil
	fake.getAllReleasesReturns = struct {
		result1 []pivnet.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessClient) GetAllReleasesReturnsOnCall(i int, result1 []pivnet.Release, result2 error) {
	fake.getAllReleasesMutex.Lock()
	defer fake.getAllReleasesMutex.Unlock()
	fake.GetAllReleasesStub = nil
	if fake.getAllReleasesReturnsOnCall == nil {
		fake.getAllReleasesReturnsOnCall = make(map[int]struct {
			result1 []pivnet.Release
			result2 error
		})
	}
	fake.getAllReleasesReturnsOnCall[i] = struct {
		result1 []pivnet.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessClient) GetLatestPublicReleaseByReleaseType(arg1 int, arg2 pivnet.ReleaseType) (pivnet.Release, error) {
	fake.getLatestPublicReleaseByReleaseTypeMutex.Lock()
	ret, specificReturn := fake.getLatestPublicReleaseByReleaseTypeReturnsOnCall[len(fake.getLatestPublicReleaseByReleaseTypeArgsForCall)]
	fake.getLatestPublicReleaseByReleaseTypeArgsForCall = append(fake.getLatestPublicReleaseByReleaseTypeArgsForCall, struct {
		arg1 int
		arg2 pivnet.ReleaseType
	}{arg1, arg2})
	fake.recordInvocation("GetLatestPublicReleaseByReleaseType", []interface{}{arg1, arg2})
	fake.getLatestPublicReleaseByReleaseTypeMutex.Unlock()
	if fake.GetLatestPublicReleaseByReleaseTypeStub != nil {
		return fake.GetLatestPublicReleaseByReleaseTypeStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getLatestPublicReleaseByReleaseTypeReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccessClient) GetLatestPublicReleaseByReleaseTypeCallCount() int {
	fake.getLatestPublicReleaseByReleaseTypeMutex.RLock()
	defer fake.getLatestPublicReleaseByReleaseTypeMutex.RUnlock()
	return len(fake.getLatestPublicReleaseByReleaseTypeArgsForCall)
}

func (fake *FakeAccessClient) GetLatestPublicReleaseByReleaseTypeCalls(stub func(int, pivnet.ReleaseType) (pivnet.Release, error)) {
	fake.getLatestPublicReleaseByReleaseTypeMutex.Lock()
	defer fake.getLatestPublicReleaseByReleaseTypeMutex.Unlock()
	fake.GetLatestPublicReleaseByReleaseTypeStub = stub
}

func (fake *FakeAccessClient) GetLatestPublicReleaseByReleaseTypeArgsForCall(i int) (int, pivnet.ReleaseType) {
	fake.getLatestPublicReleaseByReleaseTypeMutex.RLock()
	defer fake.getLatestPublicReleaseByReleaseTypeMutex.RUnlock()
	argsForCall := fake.getLatestPublicReleaseByReleaseTypeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeAccessClient) GetLatestPublicReleaseByReleaseTypeReturns(result1 pivnet.Release, result2 error) {
	fake.getLatestPublicReleaseByReleaseTypeMutex.Lock()
	defer fake.getLatestPublicReleaseByReleaseTypeMutex.Unlock()
	fake.GetLatestPublicReleaseByReleaseTypeStub = nil
	fake.getLatestPublicReleaseByReleaseTypeReturns = struct {
		result1 pivnet.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessClient) GetLatestPublicReleaseByReleaseTypeReturnsOnCall(i int, result1 pivnet.Release, result2 error) {
	fake.getLatestPublicReleaseByReleaseTypeMutex.Lock()
	defer fake.getLatestPublicReleaseByReleaseTypeMutex.Unlock()
	fake.GetLatestPublicReleaseByReleaseTypeStub = nil
	if fake.getLatestPublicReleaseByReleaseTypeReturnsOnCall == nil {
		fake.getLatestPublicReleaseByReleaseTypeReturnsOnCall = make(map[int]struct {
			result1 pivnet.Release
			result2 error
		})
	}
	fake.getLatestPublicReleaseByReleaseTypeReturnsOnCall[i] = struct {
		result1 pivnet.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessClient) UpdateRelease(arg1 pivnet.Release) (pivnet.Release, error) {
	fake.updateReleaseMutex.Lock()
	ret, specificReturn := fake.updateReleaseReturnsOnCall[len(fake.updateReleaseArgsForCall)]
	fake.updateReleaseArgsForCall = append(fake.updateReleaseArgsForCall, struct {
		arg1 pivnet.Release
	}{arg1})
	fake.recordInvocation("UpdateRelease", []interface{}{arg1})
	fake.updateReleaseMutex.Unlock()
	if fake.UpdateReleaseStub != nil {
		return fake.UpdateReleaseStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateReleaseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeAccessClient) UpdateReleaseCallCount() int {
	fake.updateReleaseMutex.RLock()
	defer fake.updateReleaseMutex.RUnlock()
	return len(fake.updateReleaseArgsForCall)
}

func (fake *FakeAccessClient) UpdateReleaseCalls(stub func(pivnet.Release) (pivnet.Release, error)) {
	fake.updateReleaseMutex.Lock()
	defer fake.updateReleaseMutex.Unlock()
	fake.UpdateReleaseStub = stub
}

func (fake *FakeAccessClient) UpdateReleaseArgsForCall(i int) pivnet.Release {
	fake.updateReleaseMutex.RLock()
	defer fake.updateReleaseMutex.RUnlock()
	argsForCall := fake.updateReleaseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeAccessClient) UpdateReleaseReturns(result1 pivnet.Release, result2 error) {
	fake.updateReleaseMutex.Lock()
	defer fake.updateReleaseMutex.Unlock()
	fake.UpdateReleaseStub = nil
	fake.updateReleaseReturns = struct {
		result1 pivnet.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessClient) UpdateReleaseReturnsOnCall(i int, result1 pivnet.Release, result2 error) {
	fake.updateReleaseMutex.Lock()
	defer fake.updateReleaseMutex.Unlock()
	fake.UpdateReleaseStub = nil
	if fake.updateReleaseReturnsOnCall == nil {
		fake.updateReleaseReturnsOnCall = make(map[int]struct {
			result1 pivnet.Release
			result2 error
		})
	}
	fake.updateReleaseReturnsOnCall[i] = struct {
		result1 pivnet.Release
		result2 error
	}{result1, result2}
}

func (fake *FakeAccessClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addFileGroupToReleaseMutex.RLock()
	defer fake.addFileGroupToReleaseMutex.RUnlock()
	fake.addProductFileToFileGroupMutex.RLock()
	defer fake.addProductFileToFileGroupMutex.RUnlock()
	fake.addProductFileToReleaseMutex.RLock()
	defer fake.addProductFileToReleaseMutex.RUnlock()
	fake.createFederationTokenMutex.RLock()
	defer fake.createFederationTokenMutex.RUnlock()
	fake.createFileGroupMutex.RLock()
	defer fake.createFileGroupMutex.RUnlock()
	fake.createProductFileMutex.RLock()
	defer fake.createProductFileMutex.RUnlock()
	fake.createReleaseMutex.RLock()
	defer fake.createReleaseMutex.RUnlock()
	fake.deleteProductFileMutex.RLock()
	defer fake.deleteProductFileMutex.RUnlock()
	fake.fileTransferStatusInProgressMutex.RLock()
	defer fake.fileTransferStatusInProgressMutex.RUnlock()
	fake.getAllReleasesMutex.RLock()
	defer fake.getAllReleasesMutex.RUnlock()
	fake.getLatestPublicReleaseByReleaseTypeMutex.RLock()
	defer fake.getLatestPublicReleaseByReleaseTypeMutex.RUnlock()
	fake.updateReleaseMutex.RLock()
	defer fake.updateReleaseMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeAccessClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ api.AccessClient = new(FakeAccessClient)
