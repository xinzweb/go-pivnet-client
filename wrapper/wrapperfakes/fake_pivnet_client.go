// Code generated by counterfeiter. DO NOT EDIT.
package wrapperfakes

import (
	"sync"

	"github.com/baotingfang/go-pivnet-client/wrapper"
	pivnet "github.com/pivotal-cf/go-pivnet/v4"
)

type FakePivnetClient struct {
	AddFileGroupToReleaseStub        func(string, int, int) error
	addFileGroupToReleaseMutex       sync.RWMutex
	addFileGroupToReleaseArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	addFileGroupToReleaseReturns struct {
		result1 error
	}
	addFileGroupToReleaseReturnsOnCall map[int]struct {
		result1 error
	}
	AddProductFileToFileGroupStub        func(string, int, int) error
	addProductFileToFileGroupMutex       sync.RWMutex
	addProductFileToFileGroupArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	addProductFileToFileGroupReturns struct {
		result1 error
	}
	addProductFileToFileGroupReturnsOnCall map[int]struct {
		result1 error
	}
	AddProductFileToReleaseStub        func(string, int, int) error
	addProductFileToReleaseMutex       sync.RWMutex
	addProductFileToReleaseArgsForCall []struct {
		arg1 string
		arg2 int
		arg3 int
	}
	addProductFileToReleaseReturns struct {
		result1 error
	}
	addProductFileToReleaseReturnsOnCall map[int]struct {
		result1 error
	}
	CreateFederationTokenStub        func(string) (pivnet.FederationToken, error)
	createFederationTokenMutex       sync.RWMutex
	createFederationTokenArgsForCall []struct {
		arg1 string
	}
	createFederationTokenReturns struct {
		result1 pivnet.FederationToken
		result2 error
	}
	createFederationTokenReturnsOnCall map[int]struct {
		result1 pivnet.FederationToken
		result2 error
	}
	CreateFileGroupStub        func(string, string) (pivnet.FileGroup, error)
	createFileGroupMutex       sync.RWMutex
	createFileGroupArgsForCall []struct {
		arg1 string
		arg2 string
	}
	createFileGroupReturns struct {
		result1 pivnet.FileGroup
		result2 error
	}
	createFileGroupReturnsOnCall map[int]struct {
		result1 pivnet.FileGroup
		result2 error
	}
	CreateProductFileStub        func(pivnet.CreateProductFileConfig) (pivnet.ProductFile, error)
	createProductFileMutex       sync.RWMutex
	createProductFileArgsForCall []struct {
		arg1 pivnet.CreateProductFileConfig
	}
	createProductFileReturns struct {
		result1 pivnet.ProductFile
		result2 error
	}
	createProductFileReturnsOnCall map[int]struct {
		result1 pivnet.ProductFile
		result2 error
	}
	CreateReleaseStub        func(pivnet.CreateReleaseConfig) (pivnet.Release, error)
	createReleaseMutex       sync.RWMutex
	createReleaseArgsForCall []struct {
		arg1 pivnet.CreateReleaseConfig
	}
	createReleaseReturns struct {
		result1 pivnet.Release
		result2 error
	}
	createReleaseReturnsOnCall map[int]struct {
		result1 pivnet.Release
		result2 error
	}
	DeleteProductFileStub        func(string, int) (pivnet.ProductFile, error)
	deleteProductFileMutex       sync.RWMutex
	deleteProductFileArgsForCall []struct {
		arg1 string
		arg2 int
	}
	deleteProductFileReturns struct {
		result1 pivnet.ProductFile
		result2 error
	}
	deleteProductFileReturnsOnCall map[int]struct {
		result1 pivnet.ProductFile
		result2 error
	}
	GetAllReleasesStub        func(string) ([]pivnet.Release, error)
	getAllReleasesMutex       sync.RWMutex
	getAllReleasesArgsForCall []struct {
		arg1 string
	}
	getAllReleasesReturns struct {
		result1 []pivnet.Release
		result2 error
	}
	getAllReleasesReturnsOnCall map[int]struct {
		result1 []pivnet.Release
		result2 error
	}
	GetProductFileStub        func(string, int) (pivnet.ProductFile, error)
	getProductFileMutex       sync.RWMutex
	getProductFileArgsForCall []struct {
		arg1 string
		arg2 int
	}
	getProductFileReturns struct {
		result1 pivnet.ProductFile
		result2 error
	}
	getProductFileReturnsOnCall map[int]struct {
		result1 pivnet.ProductFile
		result2 error
	}
	UpdateReleaseStub        func(string, pivnet.Release) (pivnet.Release, error)
	updateReleaseMutex       sync.RWMutex
	updateReleaseArgsForCall []struct {
		arg1 string
		arg2 pivnet.Release
	}
	updateReleaseReturns struct {
		result1 pivnet.Release
		result2 error
	}
	updateReleaseReturnsOnCall map[int]struct {
		result1 pivnet.Release
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePivnetClient) AddFileGroupToRelease(arg1 string, arg2 int, arg3 int) error {
	fake.addFileGroupToReleaseMutex.Lock()
	ret, specificReturn := fake.addFileGroupToReleaseReturnsOnCall[len(fake.addFileGroupToReleaseArgsForCall)]
	fake.addFileGroupToReleaseArgsForCall = append(fake.addFileGroupToReleaseArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	fake.recordInvocation("AddFileGroupToRelease", []interface{}{arg1, arg2, arg3})
	fake.addFileGroupToReleaseMutex.Unlock()
	if fake.AddFileGroupToReleaseStub != nil {
		return fake.AddFileGroupToReleaseStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.addFileGroupToReleaseReturns
	return fakeReturns.result1
}

func (fake *FakePivnetClient) AddFileGroupToReleaseCallCount() int {
	fake.addFileGroupToReleaseMutex.RLock()
	defer fake.addFileGroupToReleaseMutex.RUnlock()
	return len(fake.addFileGroupToReleaseArgsForCall)
}

func (fake *FakePivnetClient) AddFileGroupToReleaseCalls(stub func(string, int, int) error) {
	fake.addFileGroupToReleaseMutex.Lock()
	defer fake.addFileGroupToReleaseMutex.Unlock()
	fake.AddFileGroupToReleaseStub = stub
}

func (fake *FakePivnetClient) AddFileGroupToReleaseArgsForCall(i int) (string, int, int) {
	fake.addFileGroupToReleaseMutex.RLock()
	defer fake.addFileGroupToReleaseMutex.RUnlock()
	argsForCall := fake.addFileGroupToReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePivnetClient) AddFileGroupToReleaseReturns(result1 error) {
	fake.addFileGroupToReleaseMutex.Lock()
	defer fake.addFileGroupToReleaseMutex.Unlock()
	fake.AddFileGroupToReleaseStub = nil
	fake.addFileGroupToReleaseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) AddFileGroupToReleaseReturnsOnCall(i int, result1 error) {
	fake.addFileGroupToReleaseMutex.Lock()
	defer fake.addFileGroupToReleaseMutex.Unlock()
	fake.AddFileGroupToReleaseStub = nil
	if fake.addFileGroupToReleaseReturnsOnCall == nil {
		fake.addFileGroupToReleaseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addFileGroupToReleaseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) AddProductFileToFileGroup(arg1 string, arg2 int, arg3 int) error {
	fake.addProductFileToFileGroupMutex.Lock()
	ret, specificReturn := fake.addProductFileToFileGroupReturnsOnCall[len(fake.addProductFileToFileGroupArgsForCall)]
	fake.addProductFileToFileGroupArgsForCall = append(fake.addProductFileToFileGroupArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	fake.recordInvocation("AddProductFileToFileGroup", []interface{}{arg1, arg2, arg3})
	fake.addProductFileToFileGroupMutex.Unlock()
	if fake.AddProductFileToFileGroupStub != nil {
		return fake.AddProductFileToFileGroupStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.addProductFileToFileGroupReturns
	return fakeReturns.result1
}

func (fake *FakePivnetClient) AddProductFileToFileGroupCallCount() int {
	fake.addProductFileToFileGroupMutex.RLock()
	defer fake.addProductFileToFileGroupMutex.RUnlock()
	return len(fake.addProductFileToFileGroupArgsForCall)
}

func (fake *FakePivnetClient) AddProductFileToFileGroupCalls(stub func(string, int, int) error) {
	fake.addProductFileToFileGroupMutex.Lock()
	defer fake.addProductFileToFileGroupMutex.Unlock()
	fake.AddProductFileToFileGroupStub = stub
}

func (fake *FakePivnetClient) AddProductFileToFileGroupArgsForCall(i int) (string, int, int) {
	fake.addProductFileToFileGroupMutex.RLock()
	defer fake.addProductFileToFileGroupMutex.RUnlock()
	argsForCall := fake.addProductFileToFileGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePivnetClient) AddProductFileToFileGroupReturns(result1 error) {
	fake.addProductFileToFileGroupMutex.Lock()
	defer fake.addProductFileToFileGroupMutex.Unlock()
	fake.AddProductFileToFileGroupStub = nil
	fake.addProductFileToFileGroupReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) AddProductFileToFileGroupReturnsOnCall(i int, result1 error) {
	fake.addProductFileToFileGroupMutex.Lock()
	defer fake.addProductFileToFileGroupMutex.Unlock()
	fake.AddProductFileToFileGroupStub = nil
	if fake.addProductFileToFileGroupReturnsOnCall == nil {
		fake.addProductFileToFileGroupReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addProductFileToFileGroupReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) AddProductFileToRelease(arg1 string, arg2 int, arg3 int) error {
	fake.addProductFileToReleaseMutex.Lock()
	ret, specificReturn := fake.addProductFileToReleaseReturnsOnCall[len(fake.addProductFileToReleaseArgsForCall)]
	fake.addProductFileToReleaseArgsForCall = append(fake.addProductFileToReleaseArgsForCall, struct {
		arg1 string
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	fake.recordInvocation("AddProductFileToRelease", []interface{}{arg1, arg2, arg3})
	fake.addProductFileToReleaseMutex.Unlock()
	if fake.AddProductFileToReleaseStub != nil {
		return fake.AddProductFileToReleaseStub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.addProductFileToReleaseReturns
	return fakeReturns.result1
}

func (fake *FakePivnetClient) AddProductFileToReleaseCallCount() int {
	fake.addProductFileToReleaseMutex.RLock()
	defer fake.addProductFileToReleaseMutex.RUnlock()
	return len(fake.addProductFileToReleaseArgsForCall)
}

func (fake *FakePivnetClient) AddProductFileToReleaseCalls(stub func(string, int, int) error) {
	fake.addProductFileToReleaseMutex.Lock()
	defer fake.addProductFileToReleaseMutex.Unlock()
	fake.AddProductFileToReleaseStub = stub
}

func (fake *FakePivnetClient) AddProductFileToReleaseArgsForCall(i int) (string, int, int) {
	fake.addProductFileToReleaseMutex.RLock()
	defer fake.addProductFileToReleaseMutex.RUnlock()
	argsForCall := fake.addProductFileToReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePivnetClient) AddProductFileToReleaseReturns(result1 error) {
	fake.addProductFileToReleaseMutex.Lock()
	defer fake.addProductFileToReleaseMutex.Unlock()
	fake.AddProductFileToReleaseStub = nil
	fake.addProductFileToReleaseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) AddProductFileToReleaseReturnsOnCall(i int, result1 error) {
	fake.addProductFileToReleaseMutex.Lock()
	defer fake.addProductFileToReleaseMutex.Unlock()
	fake.AddProductFileToReleaseStub = nil
	if fake.addProductFileToReleaseReturnsOnCall == nil {
		fake.addProductFileToReleaseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addProductFileToReleaseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePivnetClient) CreateFederationToken(arg1 string) (pivnet.FederationToken, error) {
	fake.createFederationTokenMutex.Lock()
	ret, specificReturn := fake.createFederationTokenReturnsOnCall[len(fake.createFederationTokenArgsForCall)]
	fake.createFederationTokenArgsForCall = append(fake.createFederationTokenArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("CreateFederationToken", []interface{}{arg1})
	fake.createFederationTokenMutex.Unlock()
	if fake.CreateFederationTokenStub != nil {
		return fake.CreateFederationTokenStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createFederationTokenReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) CreateFederationTokenCallCount() int {
	fake.createFederationTokenMutex.RLock()
	defer fake.createFederationTokenMutex.RUnlock()
	return len(fake.createFederationTokenArgsForCall)
}

func (fake *FakePivnetClient) CreateFederationTokenCalls(stub func(string) (pivnet.FederationToken, error)) {
	fake.createFederationTokenMutex.Lock()
	defer fake.createFederationTokenMutex.Unlock()
	fake.CreateFederationTokenStub = stub
}

func (fake *FakePivnetClient) CreateFederationTokenArgsForCall(i int) string {
	fake.createFederationTokenMutex.RLock()
	defer fake.createFederationTokenMutex.RUnlock()
	argsForCall := fake.createFederationTokenArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePivnetClient) CreateFederationTokenReturns(result1 pivnet.FederationToken, result2 error) {
	fake.createFederationTokenMutex.Lock()
	defer fake.createFederationTokenMutex.Unlock()
	fake.CreateFederationTokenStub = nil
	fake.createFederationTokenReturns = struct {
		result1 pivnet.FederationToken
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) CreateFederationTokenReturnsOnCall(i int, result1 pivnet.FederationToken, result2 error) {
	fake.createFederationTokenMutex.Lock()
	defer fake.createFederationTokenMutex.Unlock()
	fake.CreateFederationTokenStub = nil
	if fake.createFederationTokenReturnsOnCall == nil {
		fake.createFederationTokenReturnsOnCall = make(map[int]struct {
			result1 pivnet.FederationToken
			result2 error
		})
	}
	fake.createFederationTokenReturnsOnCall[i] = struct {
		result1 pivnet.FederationToken
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) CreateFileGroup(arg1 string, arg2 string) (pivnet.FileGroup, error) {
	fake.createFileGroupMutex.Lock()
	ret, specificReturn := fake.createFileGroupReturnsOnCall[len(fake.createFileGroupArgsForCall)]
	fake.createFileGroupArgsForCall = append(fake.createFileGroupArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("CreateFileGroup", []interface{}{arg1, arg2})
	fake.createFileGroupMutex.Unlock()
	if fake.CreateFileGroupStub != nil {
		return fake.CreateFileGroupStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createFileGroupReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) CreateFileGroupCallCount() int {
	fake.createFileGroupMutex.RLock()
	defer fake.createFileGroupMutex.RUnlock()
	return len(fake.createFileGroupArgsForCall)
}

func (fake *FakePivnetClient) CreateFileGroupCalls(stub func(string, string) (pivnet.FileGroup, error)) {
	fake.createFileGroupMutex.Lock()
	defer fake.createFileGroupMutex.Unlock()
	fake.CreateFileGroupStub = stub
}

func (fake *FakePivnetClient) CreateFileGroupArgsForCall(i int) (string, string) {
	fake.createFileGroupMutex.RLock()
	defer fake.createFileGroupMutex.RUnlock()
	argsForCall := fake.createFileGroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) CreateFileGroupReturns(result1 pivnet.FileGroup, result2 error) {
	fake.createFileGroupMutex.Lock()
	defer fake.createFileGroupMutex.Unlock()
	fake.CreateFileGroupStub = nil
	fake.createFileGroupReturns = struct {
		result1 pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) CreateFileGroupReturnsOnCall(i int, result1 pivnet.FileGroup, result2 error) {
	fake.createFileGroupMutex.Lock()
	defer fake.createFileGroupMutex.Unlock()
	fake.CreateFileGroupStub = nil
	if fake.createFileGroupReturnsOnCall == nil {
		fake.createFileGroupReturnsOnCall = make(map[int]struct {
			result1 pivnet.FileGroup
			result2 error
		})
	}
	fake.createFileGroupReturnsOnCall[i] = struct {
		result1 pivnet.FileGroup
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) CreateProductFile(arg1 pivnet.CreateProductFileConfig) (pivnet.ProductFile, error) {
	fake.createProductFileMutex.Lock()
	ret, specificReturn := fake.createProductFileReturnsOnCall[len(fake.createProductFileArgsForCall)]
	fake.createProductFileArgsForCall = append(fake.createProductFileArgsForCall, struct {
		arg1 pivnet.CreateProductFileConfig
	}{arg1})
	fake.recordInvocation("CreateProductFile", []interface{}{arg1})
	fake.createProductFileMutex.Unlock()
	if fake.CreateProductFileStub != nil {
		return fake.CreateProductFileStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createProductFileReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) CreateProductFileCallCount() int {
	fake.createProductFileMutex.RLock()
	defer fake.createProductFileMutex.RUnlock()
	return len(fake.createProductFileArgsForCall)
}

func (fake *FakePivnetClient) CreateProductFileCalls(stub func(pivnet.CreateProductFileConfig) (pivnet.ProductFile, error)) {
	fake.createProductFileMutex.Lock()
	defer fake.createProductFileMutex.Unlock()
	fake.CreateProductFileStub = stub
}

func (fake *FakePivnetClient) CreateProductFileArgsForCall(i int) pivnet.CreateProductFileConfig {
	fake.createProductFileMutex.RLock()
	defer fake.createProductFileMutex.RUnlock()
	argsForCall := fake.createProductFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePivnetClient) CreateProductFileReturns(result1 pivnet.ProductFile, result2 error) {
	fake.createProductFileMutex.Lock()
	defer fake.createProductFileMutex.Unlock()
	fake.CreateProductFileStub = nil
	fake.createProductFileReturns = struct {
		result1 pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) CreateProductFileReturnsOnCall(i int, result1 pivnet.ProductFile, result2 error) {
	fake.createProductFileMutex.Lock()
	defer fake.createProductFileMutex.Unlock()
	fake.CreateProductFileStub = nil
	if fake.createProductFileReturnsOnCall == nil {
		fake.createProductFileReturnsOnCall = make(map[int]struct {
			result1 pivnet.ProductFile
			result2 error
		})
	}
	fake.createProductFileReturnsOnCall[i] = struct {
		result1 pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) CreateRelease(arg1 pivnet.CreateReleaseConfig) (pivnet.Release, error) {
	fake.createReleaseMutex.Lock()
	ret, specificReturn := fake.createReleaseReturnsOnCall[len(fake.createReleaseArgsForCall)]
	fake.createReleaseArgsForCall = append(fake.createReleaseArgsForCall, struct {
		arg1 pivnet.CreateReleaseConfig
	}{arg1})
	fake.recordInvocation("CreateRelease", []interface{}{arg1})
	fake.createReleaseMutex.Unlock()
	if fake.CreateReleaseStub != nil {
		return fake.CreateReleaseStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.createReleaseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) CreateReleaseCallCount() int {
	fake.createReleaseMutex.RLock()
	defer fake.createReleaseMutex.RUnlock()
	return len(fake.createReleaseArgsForCall)
}

func (fake *FakePivnetClient) CreateReleaseCalls(stub func(pivnet.CreateReleaseConfig) (pivnet.Release, error)) {
	fake.createReleaseMutex.Lock()
	defer fake.createReleaseMutex.Unlock()
	fake.CreateReleaseStub = stub
}

func (fake *FakePivnetClient) CreateReleaseArgsForCall(i int) pivnet.CreateReleaseConfig {
	fake.createReleaseMutex.RLock()
	defer fake.createReleaseMutex.RUnlock()
	argsForCall := fake.createReleaseArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePivnetClient) CreateReleaseReturns(result1 pivnet.Release, result2 error) {
	fake.createReleaseMutex.Lock()
	defer fake.createReleaseMutex.Unlock()
	fake.CreateReleaseStub = nil
	fake.createReleaseReturns = struct {
		result1 pivnet.Release
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) CreateReleaseReturnsOnCall(i int, result1 pivnet.Release, result2 error) {
	fake.createReleaseMutex.Lock()
	defer fake.createReleaseMutex.Unlock()
	fake.CreateReleaseStub = nil
	if fake.createReleaseReturnsOnCall == nil {
		fake.createReleaseReturnsOnCall = make(map[int]struct {
			result1 pivnet.Release
			result2 error
		})
	}
	fake.createReleaseReturnsOnCall[i] = struct {
		result1 pivnet.Release
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) DeleteProductFile(arg1 string, arg2 int) (pivnet.ProductFile, error) {
	fake.deleteProductFileMutex.Lock()
	ret, specificReturn := fake.deleteProductFileReturnsOnCall[len(fake.deleteProductFileArgsForCall)]
	fake.deleteProductFileArgsForCall = append(fake.deleteProductFileArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("DeleteProductFile", []interface{}{arg1, arg2})
	fake.deleteProductFileMutex.Unlock()
	if fake.DeleteProductFileStub != nil {
		return fake.DeleteProductFileStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.deleteProductFileReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) DeleteProductFileCallCount() int {
	fake.deleteProductFileMutex.RLock()
	defer fake.deleteProductFileMutex.RUnlock()
	return len(fake.deleteProductFileArgsForCall)
}

func (fake *FakePivnetClient) DeleteProductFileCalls(stub func(string, int) (pivnet.ProductFile, error)) {
	fake.deleteProductFileMutex.Lock()
	defer fake.deleteProductFileMutex.Unlock()
	fake.DeleteProductFileStub = stub
}

func (fake *FakePivnetClient) DeleteProductFileArgsForCall(i int) (string, int) {
	fake.deleteProductFileMutex.RLock()
	defer fake.deleteProductFileMutex.RUnlock()
	argsForCall := fake.deleteProductFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) DeleteProductFileReturns(result1 pivnet.ProductFile, result2 error) {
	fake.deleteProductFileMutex.Lock()
	defer fake.deleteProductFileMutex.Unlock()
	fake.DeleteProductFileStub = nil
	fake.deleteProductFileReturns = struct {
		result1 pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) DeleteProductFileReturnsOnCall(i int, result1 pivnet.ProductFile, result2 error) {
	fake.deleteProductFileMutex.Lock()
	defer fake.deleteProductFileMutex.Unlock()
	fake.DeleteProductFileStub = nil
	if fake.deleteProductFileReturnsOnCall == nil {
		fake.deleteProductFileReturnsOnCall = make(map[int]struct {
			result1 pivnet.ProductFile
			result2 error
		})
	}
	fake.deleteProductFileReturnsOnCall[i] = struct {
		result1 pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) GetAllReleases(arg1 string) ([]pivnet.Release, error) {
	fake.getAllReleasesMutex.Lock()
	ret, specificReturn := fake.getAllReleasesReturnsOnCall[len(fake.getAllReleasesArgsForCall)]
	fake.getAllReleasesArgsForCall = append(fake.getAllReleasesArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetAllReleases", []interface{}{arg1})
	fake.getAllReleasesMutex.Unlock()
	if fake.GetAllReleasesStub != nil {
		return fake.GetAllReleasesStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getAllReleasesReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) GetAllReleasesCallCount() int {
	fake.getAllReleasesMutex.RLock()
	defer fake.getAllReleasesMutex.RUnlock()
	return len(fake.getAllReleasesArgsForCall)
}

func (fake *FakePivnetClient) GetAllReleasesCalls(stub func(string) ([]pivnet.Release, error)) {
	fake.getAllReleasesMutex.Lock()
	defer fake.getAllReleasesMutex.Unlock()
	fake.GetAllReleasesStub = stub
}

func (fake *FakePivnetClient) GetAllReleasesArgsForCall(i int) string {
	fake.getAllReleasesMutex.RLock()
	defer fake.getAllReleasesMutex.RUnlock()
	argsForCall := fake.getAllReleasesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePivnetClient) GetAllReleasesReturns(result1 []pivnet.Release, result2 error) {
	fake.getAllReleasesMutex.Lock()
	defer fake.getAllReleasesMutex.Unlock()
	fake.GetAllReleasesStub = nil
	fake.getAllReleasesReturns = struct {
		result1 []pivnet.Release
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) GetAllReleasesReturnsOnCall(i int, result1 []pivnet.Release, result2 error) {
	fake.getAllReleasesMutex.Lock()
	defer fake.getAllReleasesMutex.Unlock()
	fake.GetAllReleasesStub = nil
	if fake.getAllReleasesReturnsOnCall == nil {
		fake.getAllReleasesReturnsOnCall = make(map[int]struct {
			result1 []pivnet.Release
			result2 error
		})
	}
	fake.getAllReleasesReturnsOnCall[i] = struct {
		result1 []pivnet.Release
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) GetProductFile(arg1 string, arg2 int) (pivnet.ProductFile, error) {
	fake.getProductFileMutex.Lock()
	ret, specificReturn := fake.getProductFileReturnsOnCall[len(fake.getProductFileArgsForCall)]
	fake.getProductFileArgsForCall = append(fake.getProductFileArgsForCall, struct {
		arg1 string
		arg2 int
	}{arg1, arg2})
	fake.recordInvocation("GetProductFile", []interface{}{arg1, arg2})
	fake.getProductFileMutex.Unlock()
	if fake.GetProductFileStub != nil {
		return fake.GetProductFileStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.getProductFileReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) GetProductFileCallCount() int {
	fake.getProductFileMutex.RLock()
	defer fake.getProductFileMutex.RUnlock()
	return len(fake.getProductFileArgsForCall)
}

func (fake *FakePivnetClient) GetProductFileCalls(stub func(string, int) (pivnet.ProductFile, error)) {
	fake.getProductFileMutex.Lock()
	defer fake.getProductFileMutex.Unlock()
	fake.GetProductFileStub = stub
}

func (fake *FakePivnetClient) GetProductFileArgsForCall(i int) (string, int) {
	fake.getProductFileMutex.RLock()
	defer fake.getProductFileMutex.RUnlock()
	argsForCall := fake.getProductFileArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) GetProductFileReturns(result1 pivnet.ProductFile, result2 error) {
	fake.getProductFileMutex.Lock()
	defer fake.getProductFileMutex.Unlock()
	fake.GetProductFileStub = nil
	fake.getProductFileReturns = struct {
		result1 pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) GetProductFileReturnsOnCall(i int, result1 pivnet.ProductFile, result2 error) {
	fake.getProductFileMutex.Lock()
	defer fake.getProductFileMutex.Unlock()
	fake.GetProductFileStub = nil
	if fake.getProductFileReturnsOnCall == nil {
		fake.getProductFileReturnsOnCall = make(map[int]struct {
			result1 pivnet.ProductFile
			result2 error
		})
	}
	fake.getProductFileReturnsOnCall[i] = struct {
		result1 pivnet.ProductFile
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) UpdateRelease(arg1 string, arg2 pivnet.Release) (pivnet.Release, error) {
	fake.updateReleaseMutex.Lock()
	ret, specificReturn := fake.updateReleaseReturnsOnCall[len(fake.updateReleaseArgsForCall)]
	fake.updateReleaseArgsForCall = append(fake.updateReleaseArgsForCall, struct {
		arg1 string
		arg2 pivnet.Release
	}{arg1, arg2})
	fake.recordInvocation("UpdateRelease", []interface{}{arg1, arg2})
	fake.updateReleaseMutex.Unlock()
	if fake.UpdateReleaseStub != nil {
		return fake.UpdateReleaseStub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	fakeReturns := fake.updateReleaseReturns
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePivnetClient) UpdateReleaseCallCount() int {
	fake.updateReleaseMutex.RLock()
	defer fake.updateReleaseMutex.RUnlock()
	return len(fake.updateReleaseArgsForCall)
}

func (fake *FakePivnetClient) UpdateReleaseCalls(stub func(string, pivnet.Release) (pivnet.Release, error)) {
	fake.updateReleaseMutex.Lock()
	defer fake.updateReleaseMutex.Unlock()
	fake.UpdateReleaseStub = stub
}

func (fake *FakePivnetClient) UpdateReleaseArgsForCall(i int) (string, pivnet.Release) {
	fake.updateReleaseMutex.RLock()
	defer fake.updateReleaseMutex.RUnlock()
	argsForCall := fake.updateReleaseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePivnetClient) UpdateReleaseReturns(result1 pivnet.Release, result2 error) {
	fake.updateReleaseMutex.Lock()
	defer fake.updateReleaseMutex.Unlock()
	fake.UpdateReleaseStub = nil
	fake.updateReleaseReturns = struct {
		result1 pivnet.Release
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) UpdateReleaseReturnsOnCall(i int, result1 pivnet.Release, result2 error) {
	fake.updateReleaseMutex.Lock()
	defer fake.updateReleaseMutex.Unlock()
	fake.UpdateReleaseStub = nil
	if fake.updateReleaseReturnsOnCall == nil {
		fake.updateReleaseReturnsOnCall = make(map[int]struct {
			result1 pivnet.Release
			result2 error
		})
	}
	fake.updateReleaseReturnsOnCall[i] = struct {
		result1 pivnet.Release
		result2 error
	}{result1, result2}
}

func (fake *FakePivnetClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addFileGroupToReleaseMutex.RLock()
	defer fake.addFileGroupToReleaseMutex.RUnlock()
	fake.addProductFileToFileGroupMutex.RLock()
	defer fake.addProductFileToFileGroupMutex.RUnlock()
	fake.addProductFileToReleaseMutex.RLock()
	defer fake.addProductFileToReleaseMutex.RUnlock()
	fake.createFederationTokenMutex.RLock()
	defer fake.createFederationTokenMutex.RUnlock()
	fake.createFileGroupMutex.RLock()
	defer fake.createFileGroupMutex.RUnlock()
	fake.createProductFileMutex.RLock()
	defer fake.createProductFileMutex.RUnlock()
	fake.createReleaseMutex.RLock()
	defer fake.createReleaseMutex.RUnlock()
	fake.deleteProductFileMutex.RLock()
	defer fake.deleteProductFileMutex.RUnlock()
	fake.getAllReleasesMutex.RLock()
	defer fake.getAllReleasesMutex.RUnlock()
	fake.getProductFileMutex.RLock()
	defer fake.getProductFileMutex.RUnlock()
	fake.updateReleaseMutex.RLock()
	defer fake.updateReleaseMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePivnetClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ wrapper.PivnetClient = new(FakePivnetClient)
